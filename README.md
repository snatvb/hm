# Примитивная реализация структуры Hash Map

## Пояснение по коду
В данном коде так же есть реализация связанного списка, ибо он необходим в данной структуре для борьбы с коллизиями. Есть и другой способ, но он намного менее эффективный, нежели через список.

В данном коде показана простая реализация. Так же здесь использована самописанная простейшая хэш-функция, которая может быть использована только в демонстрационных целях. Она легко может выйти за пределы number (53 бита) и так же у нее довольно большой процент коллизии.

## Борьба с коллизиями

Если ключ "A" имеет результат хеширования например 5, и ключ "B" имеет такой же результат(5), то появляется проблема коллизии, в одну ячейку хеш таблицы необходимо положить два значения, но мало положить, необходимо так же этому же ключу из будет извлечь. Так же заранее не известно возможное кол-во элементов, которые попадут в одну ячейку, потому массив здесь не подойдет. Здесь нужна структура не зависищая от размеров, такая как связанный список. По итогу необходимо будет хранить и ключ и значение в элементе связанного списка. При извлечении данных, по этому списку необходимо пробежать и найти элемент с данным ключем, чтобы извлечь значение. Хранение ключ-значение происходит в массиве фиксированной длинны из двух элементов (Иммитация работы в языках без динамически расширяющихся массивов, по идее надо было keys, values, entrines сделать так, но было принято решение не усложнять еще).

## Использование

Есть два способа использования.
Можно использовать создавая экземпляр и помощью конструктора:
```
const data = new HM()
data.set('foo', 'bar')
data.set('bar', 'baz')
console.log(data.get('foo')) // 'bar'
console.log(data.get('bar')) // 'baz'
data.remove('bar')
console.log(data.get('bar')) // undefeined
```

А можно использовать как объект в JS:
```
const obj = HM.create()
obj.foo = 'bar'
obj.bar = 'baz'
console.log(obj.foo) // 'bar'
console.log(obj.bar) // 'baz'
delete obj.bar
console.log(obj.bar) // undefined
console.log(HM.entries(obj)) // [ ['foo', 'bar'] ]
```